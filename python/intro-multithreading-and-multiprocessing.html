<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-97459416-1"> 
  </script>

  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-97459416-1');
  </script>

  <meta name="author" content="Dan Friedman">
  <meta name="geo.region" content="CA">
  <meta property="og:locale" content="en_us">
  <meta name="robot" content="all">
  <meta name="referrer" content="always">
  <meta property="fb:profile_id" content="1357771151">
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Dan Friedman's Data Science Tutorials">

  <meta property="og:see_also" content="https://twitter.com/_DanFriedman"/>
  <meta property="og:see_also" content="https://www.linkedin.com/in/danfriedman33/"/>
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@_DanFriedman">
  <meta name="twitter:image" content="https://pbs.twimg.com/profile_images/950134514113691648/7dt7ECh2_400x400.jpg" />

  <meta name="keywords" content="multithreading multiprocessing tutorial python">

  <meta name="description" content="Use multithreading and multiprocessing as options for parallel programming in Python to perform tasks at the same time">
  <meta property="og:description"  content="Use multithreading and multiprocessing as options for parallel programming in Python to perform tasks at the same time">
  <meta name="twitter:description" content="Use multithreading and multiprocessing as options for parallel programming in Python to perform tasks at the same time">

  <meta property="og:title" content="Intro to Multithreading and Multiprocessing">
  <meta name="twitter:title" content="Intro to Multithreading and Multiprocessing">

  <link rel="canonical" href="https://dfrieds.com/python/intro-multithreading-and-multiprocessing"/>

  <title>Intro to Multithreading and Multiprocessing - Python</title>

  

  <!-- Latest compiled and minified Bootstrap CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
  <link rel="stylesheet" href="https://dfrieds.com/theme/css/ie10-viewport-bug-workaround.css" />
  
  <!-- Custom styles for this template -->
  <link rel="stylesheet" href="https://dfrieds.com/theme/css/style.css" />
  <link rel="stylesheet" href="https://dfrieds.com/theme/css/notebooks.css" />
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800,900" rel="stylesheet">


  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  <link href="https://dfrieds.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Dan Friedman's Data Science Tutorials Full Atom Feed" />    <link href="https://dfrieds.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Dan Friedman's Data Science Tutorials Full RSS Feed" />      <link href="https://dfrieds.com/feeds/python.atom.xml" type="application/atom+xml" rel="alternate" title="Dan Friedman's Data Science Tutorials Categories Atom Feed" />    <link href="https://dfrieds.com/feeds/python.rss.xml" type="application/rss+xml" rel="alternate" title="Dan Friedman's Data Science Tutorials Categories RSS Feed" />    

  <!-- Start of Async Drift Code -->
  <script>
    !function() {
      var t;
      if (t = window.driftt = window.drift = window.driftt || [], !t.init) return t.invoked ? void (window.console && console.error && console.error("Drift snippet included twice.")) : (t.invoked = !0, 
        t.methods = [ "identify", "config", "track", "reset", "debug", "show", "ping", "page", "hide", "off", "on" ], 
        t.factory = function(e) {
          return function() {
            var n;
            return n = Array.prototype.slice.call(arguments), n.unshift(e), t.push(n), t;
          };
        }, t.methods.forEach(function(e) {
          t[e] = t.factory(e);
        }), t.load = function(t) {
          var e, n, o, i;
          e = 3e5, i = Math.ceil(new Date() / e) * e, o = document.createElement("script"), 
          o.type = "text/javascript", o.async = !0, o.crossorigin = "anonymous", o.src = "https://js.driftt.com/include/" + i + "/" + t + ".js", 
          n = document.getElementsByTagName("script")[0], n.parentNode.insertBefore(o, n);
        });
      }();
    drift.SNIPPET_VERSION = '0.3.1';
    drift.load('83xk3ceba36c');
  </script>
  <!-- End of Async Drift Code -->


</head>

<body>
  <div class="python"></div>

  <nav class="navbar navbar-expand-sm fixed-top">
    <div class="container">
      <a class="navbar-brand" href="https://dfrieds.com/">Dan<span class="green">_</span>Friedman</a>
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
      aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggle-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="nav navbar-nav mr-auto">
        </ul>
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link" href="https://dfrieds.com/#articles">Articles
              </a>
            </li>
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Tutorials
              </a>
              
              <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                <a class="dropdown-item" href="https://dfrieds.com/#python">Python</a>
                <a class="dropdown-item" href="https://dfrieds.com/#dataviz">Data Visualizations</a>
                <a class="dropdown-item" href="https://dfrieds.com/#data-analysis">Data Analysis with pandas</a>
                <a class="dropdown-item" href="https://dfrieds.com/#math">Math</a>
                <a class="dropdown-item" href="https://dfrieds.com/#ml">Machine Learning</a>
              </div>
            </li>
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">About
              </a>
              <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                <a class="dropdown-item" href="https://twitter.com/_DanFriedman" target="blank">Twitter</a>
                <a class="dropdown-item" href="https://github.com/frieds" target="blank">GitHub</a>
                <a class="dropdown-item" href="https://linkedin.com/in/danfriedman33" target="blank">LinkedIn</a>
              </div>
            </li>
          </ul>
      </div>
    </div>
  </nav>


  <!-- end of header section -->
  <div class="container">

<section id="content" class="body">
  <header>
    <div class="posttype"> Python Intermediate Concepts Tutorial</div>
    <h1 class="articleh1">
      Intro to Multithreading and Multiprocessing
    </h1>

    <ul class ="row article_info">
      
      <li>
        Apr 25&nbsp;&nbsp;&bull;&nbsp;&nbsp;19 min read
      </li>
      <li class="tagarticle">
        Key Terms:         multithreading,
        multiprocessing
      </li>
    </ul>
  </header>

  <div class='article_content'>
    <h3>Why is Performant Code Important</h3>
<p>In analyzing data, you may be dealing with thousands, millions or even billions of records. As you perform computations to gain insights, you'll likely do lots of data transformations.</p>
<p>With each computation, to save even seconds or minutes can be greatly helpful for you to deliver insights to your team faster and ultimately get more work done over time.</p>
<p>With parallel programming in Python, you can do just that.</p>
<h3>Brief Overview</h3>
<h4>Intro to Parallelism</h4>
<p><strong>Parallelism</strong> (aka parallel programming) is when two or more tasks run <em>at the same time</em>. There's important terminology to understand regarding parallelism too.</p>
<p>A <strong>thread</strong> is an execution context for code.</p>
<p>A <strong>process</strong> is a program and state of all threads executing in a program.</p>
<p>One process can have several threads running <em>at the same time</em>. One program could also have several proccess running <em>at the same time</em>.</p>
<p>In Python, by default programs run as a single process with a single thread of execution; this uses just a single CPU. </p>
<p>Examples parallelism can help with:</p>
<ul>
<li>executing database queries</li>
<li>pre-processing lots of images to use for machine learning</li>
<li>web crawling </li>
</ul>
<h4>CPU &amp; Core</h4>
<p>The CPU (central processing unit) manages the computational work of the computer. CPUs have one or more cores which allow for code to be executed simultaneously. </p>
<p>My Macbook Pro has 4 cores.</p>
<p>A single core can perform a number of computations in a limited amount of time. However, if a Python program uses another process running on another core, we greatly decrease the program's runtime.</p>
<h4>Python's Global Interpreter Lock</h4>
<p>CPython (the standard python implementation) has something called the GIL (Global Interpreter Lock); the GIL prevents two threads from executing simultaneously in the same program. However, two threads can run concurrently and one can run code while another may be waiting.</p>
<p>The GIL limits parallel programming in Python out of the box.</p>
<h4>When to use threads versus processes</h4>
<p><strong>Threads</strong> are typically best for IO tasks or tasks involving external systems since threads work well to combine results quickly. On the other hand, processes need to pickle their results and therefore take more time to combine results from multiple processes.</p>
<p><strong>Threads</strong> provide no benefit for expensive CPU tasks since threads must run within the GIL.</p>
<p><strong>Multiple processes</strong> can speed up Python operations that are CPU intensive because they can utilize multiple cores and avoid Python's GIL.</p>
<h3><code>map</code> Function and Example</h3>
<p>The use of <code>map</code> will be applied in our parallel programming examples later; so I'll provide a brief introduction now.</p>
<p>Below I wrote a function called <code>number_times_two</code> to take in a number, multiply it by two and return the result.</p>
<p><code>map</code> is a built-in Python function that helps us easily apply a function over every item in an iterable such as a list. </p>
<p>We'll use the <code>map</code> function to apply <code>number_times_two</code> to every element in the list of numbers <code>[1, 2, 3, 4]</code>.</p>
<p>This table illustrates the operations that will take place.</p>
<table>
<thead>
<tr>
<th>Input</th>
<th>number_times_two Operation</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1*2</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>2*2</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>3*2</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>4*2</td>
<td>8</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">number_times_two</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply a number by 2</span>

<span class="sd">    :param number: a value we&#39;ll use in our computation</span>
<span class="sd">    :type number: (preferably an) int</span>

<span class="sd">    :returns: number*2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">number</span><span class="o">*</span><span class="mi">2</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">number_times_two</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>function
</pre></div>


<p>The <code>map</code> function returns an <em>map object</em> that is an <em>iterator</em>.</p>
<div class="highlight"><pre><span></span><span class="nb">map</span><span class="p">(</span><span class="n">number_times_two</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>


<div class="highlight"><pre><span></span>&lt;map at 0x10f325198&gt;
</pre></div>


<p>We can call the built-in <code>list</code> function to output our result, the <em>map</em> object, as a list.</p>
<div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">number_times_two</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
</pre></div>


<div class="highlight"><pre><span></span>[2, 4, 6, 8]
</pre></div>


<h3>Parallelism</h3>
<h4>Import Modules</h4>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">requests</span> <span class="kn">import</span> <span class="n">get</span>
<span class="kn">from</span> <span class="nn">multiprocessing.dummy</span> <span class="kn">import</span> <span class="n">Pool</span> <span class="k">as</span> <span class="n">ThreadPool</span> 
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">sample</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</pre></div>


<h4>Helper Functions</h4>
<p>These functions below will help us visually illustrate the effect of multithreading so it's easier to understand.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">multithreading</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">number_of_threads</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps a function across an iterable (such as a list of elements) with the optional use of multithreading.</span>

<span class="sd">    :param function: name of a function</span>
<span class="sd">    :type function: function</span>

<span class="sd">    :param iterable: elements used as inputs to function parameter</span>
<span class="sd">    :type iterable: list</span>

<span class="sd">    :param number_of_threads: number of threads to use in map operation</span>
<span class="sd">    :type number_of_threads: int</span>

<span class="sd">    :returns list_objects: return objects from our function parameter calls</span>
<span class="sd">    :return type: list</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">number_of_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_multiprocessing</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">number_of_concurrent_processes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps a function across an iterable (such as a list of elements) with the optional use of multiprocessing.</span>

<span class="sd">    :param function: name of a function</span>
<span class="sd">    :type function: function</span>

<span class="sd">    :param iterable: elements used as inputs to function parameter</span>
<span class="sd">    :type iterable: list</span>

<span class="sd">    :param number_of_concurrent_processes: number of concurrent processes in multiprocessing</span>
<span class="sd">    :type number_of_concurrent_processes: int</span>

<span class="sd">    :returns list_objects: return objects from our function parameter calls</span>
<span class="sd">    :return type: list</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">number_of_concurrent_processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transform_timestamps_to_be_seconds_from_process_start_time</span><span class="p">(</span><span class="n">process_start_time</span><span class="p">,</span> <span class="n">all_task_timestamps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take list of start and end timestamps of # of seconds since epoch, and subtract the process start time from them all</span>

<span class="sd">    Therefore we&#39;ll know how far timestamps are from the 0th second, the start of the program.</span>

<span class="sd">    :param process_start_time: # of seconds since epoch for start of task</span>
<span class="sd">    :type process_start_time: float</span>

<span class="sd">    :param all_task_timestamps: # of seconds since epoch for end of task</span>
<span class="sd">    :type all_task_timestamps: list</span>

<span class="sd">    :return function_timestamps_starting_from_zero: same shape as all_task_timestamps but all values subtracted by process_start_time</span>
<span class="sd">    :type function_timestamps_starting_from_zero: numpy array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">function_timestamps_starting_from_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_task_timestamps</span><span class="p">)</span> <span class="o">-</span> <span class="n">process_start_time</span>
    <span class="k">return</span> <span class="n">function_timestamps_starting_from_zero</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">separate_list_elements</span><span class="p">(</span><span class="n">list_of_lists</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list structure such as [[x, y], [x, y]] return a list of just the x&#39;s and another of just y&#39;s</span>

<span class="sd">    :param list_of_lists: list with nested lists</span>
<span class="sd">    :type list_of_list: list</span>

<span class="sd">    :return start_values, end_values: two lists - one of all 0-th index values and another of 1st index values in each nested list</span>
<span class="sd">    :return type: tuple storing two lists</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">inner_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">inner_list</span> <span class="ow">in</span> <span class="n">list_of_lists</span><span class="p">]</span>
    <span class="n">start_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_values</span><span class="p">)</span>

    <span class="n">end_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">inner_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">inner_list</span> <span class="ow">in</span> <span class="n">list_of_lists</span><span class="p">]</span>
    <span class="n">end_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">start_values</span><span class="p">,</span> <span class="n">end_values</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_bar_colors</span><span class="p">(</span><span class="n">number_of_threads_or_subprocesses</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a list of colors the same length as the number of threads or number of concurrent subprocesses</span>

<span class="sd">    :param number_of_threads_or_subprocesses: number of threads used in multithreading or number of processes used in multiprocessing</span>
<span class="sd">    :type number_of_threads_or_subprocesses: int</span>

<span class="sd">    :return colors: list of colors chosen from good_colors</span>
<span class="sd">    :type colors: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">good_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;firebrick&#39;</span><span class="p">,</span> <span class="s1">&#39;darkgreen&#39;</span><span class="p">,</span> <span class="s1">&#39;royalblue&#39;</span><span class="p">,</span> <span class="s1">&#39;rebeccapurple&#39;</span><span class="p">,</span> <span class="s1">&#39;dimgrey&#39;</span><span class="p">,</span> <span class="s1">&#39;teal&#39;</span><span class="p">,</span> <span class="s1">&#39;chocolate&#39;</span><span class="p">,</span> <span class="s1">&#39;darkgoldenrod&#39;</span><span class="p">]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="n">good_colors</span><span class="p">,</span> <span class="n">number_of_threads_or_subprocesses</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">colors</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_task_times</span><span class="p">(</span><span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span><span class="p">,</span> <span class="n">plot_title</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use Matplotlib module to create a horizontal bar chart of the time elapsed for each task.</span>

<span class="sd">    :param start_times: start times of tasks</span>
<span class="sd">    :type start_times: list</span>

<span class="sd">    :param end_times: end times of tasks</span>
<span class="sd">    :type end_times: list</span>

<span class="sd">    :param plot_title: title of plot</span>
<span class="sd">    :type plot_title: string</span>

<span class="sd">    :param colors: colors of bars</span>
<span class="sd">    :type colors: list</span>

<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">barh</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_times</span><span class="p">)),</span> <span class="n">end_times</span><span class="o">-</span><span class="n">start_times</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">start_times</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Tasks&quot;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Seconds&quot;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">plot_title</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
    <span class="k">return</span> <span class="bp">None</span><span class="p">;</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="p">,</span> <span class="n">function_name</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">plot_title</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform multithreading given a function_name and number_of_threads and visualize tasks as bar chart</span>

<span class="sd">    :param number_of_concurrent_processes: number of concurrent processes in multiprocessing</span>
<span class="sd">    :type number_of_concurrent_processes: int</span>

<span class="sd">    :param function_name: name of function applied in multithreading operation</span>
<span class="sd">    :type function_name: function</span>

<span class="sd">    :param iterable: elements used as inputs to function parameter</span>
<span class="sd">    :type iterable: list</span>

<span class="sd">    :param plot_title: title of plot</span>
<span class="sd">    :type plot_title: string</span>

<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">process_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="c1"># we track time here </span>
    <span class="n">time_logs_multiprocessing_op</span> <span class="o">=</span> <span class="n">do_multiprocessing</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">number_of_concurrent_processes</span><span class="p">)</span>
    <span class="n">multiprocessing_task_timestamps</span> <span class="o">=</span> <span class="n">transform_timestamps_to_be_seconds_from_process_start_time</span><span class="p">(</span><span class="n">process_start_time</span><span class="p">,</span> <span class="n">time_logs_multiprocessing_op</span><span class="p">)</span>
    <span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span> <span class="o">=</span> <span class="n">separate_list_elements</span><span class="p">(</span><span class="n">multiprocessing_task_timestamps</span><span class="p">)</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">generate_bar_colors</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="p">)</span>
    <span class="n">visualize_task_times</span><span class="p">(</span><span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span><span class="p">,</span> <span class="n">plot_title</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_multithreading_effect</span><span class="p">(</span><span class="n">number_of_threads</span><span class="p">,</span> <span class="n">function_name</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">plot_title</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform multithreading given a function_name and number_of_threads and visualize tasks as bar chart</span>

<span class="sd">    :param number_of_threads: number of threads used in multithreading</span>
<span class="sd">    :type number_of_threads: int</span>

<span class="sd">    :param function_name: name of function applied in multithreading operation</span>
<span class="sd">    :type function_name: function</span>

<span class="sd">    :param iterable: elements used as inputs to function parameter</span>
<span class="sd">    :type iterable: list</span>

<span class="sd">    :param plot_title: title of plot</span>
<span class="sd">    :type plot_title: string</span>

<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">process_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="c1"># we track time here </span>
    <span class="n">time_logs_multithreading_op</span> <span class="o">=</span> <span class="n">multithreading</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">number_of_threads</span><span class="p">)</span>
    <span class="n">multithreading_task_timestamps</span> <span class="o">=</span> <span class="n">transform_timestamps_to_be_seconds_from_process_start_time</span><span class="p">(</span><span class="n">process_start_time</span><span class="p">,</span> <span class="n">time_logs_multithreading_op</span><span class="p">)</span>
    <span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span> <span class="o">=</span> <span class="n">separate_list_elements</span><span class="p">(</span><span class="n">multithreading_task_timestamps</span><span class="p">)</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">generate_bar_colors</span><span class="p">(</span><span class="n">number_of_threads</span><span class="p">)</span>
    <span class="n">visualize_task_times</span><span class="p">(</span><span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span><span class="p">,</span> <span class="n">plot_title</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
</pre></div>


<h3>Measure Server Response Times</h3>
<p>This is a popular example on the web. For a long list of URLs, we'll use the <code>requests</code> module to <code>get</code> a <em>response object</em>. </p>
<p>With this <em>response object</em>, we could later perform operations to see the status of the request, get the contents of the site and more!</p>
<div class="highlight"><pre><span></span><span class="n">twelve_urls</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://secure.capitalbikeshare.com/map/&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">16</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_response_time_measurements</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    mark start time, then call the get method and pass in a url to receive a server response object, then mark end time</span>

<span class="sd">    :param url: address of a worldwide web page </span>
<span class="sd">    :type url: string</span>

<span class="sd">    :returns: start_time and stop_time of this task</span>
<span class="sd">    :type returns: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exception_object</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Error with request for url: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
    <span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">start_time</span><span class="p">,</span> <span class="n">stop_time</span><span class="p">]</span>
</pre></div>


<p>First, just to illustrate our <code>multithreading</code> function, I'll call the <code>multithreading</code> function relevant to this example.</p>
<p>We'll be return a list of nested lists, in which each nested list will contain the start timestamp and end timestamp of each task - each task being getting a new server response.</p>
<div class="highlight"><pre><span></span><span class="n">multithreading</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span> <span class="n">number_of_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>[[1524632208.212652, 1524632209.3562171],
 [1524632209.356304, 1524632210.377363],
 [1524632210.377422, 1524632211.401835],
 [1524632211.401959, 1524632212.424235],
 [1524632212.424294, 1524632213.458614],
 [1524632213.458688, 1524632214.472278],
 [1524632214.4723809, 1524632215.3774521],
 [1524632215.377533, 1524632216.250168],
 [1524632216.250221, 1524632217.121071],
 [1524632217.1211221, 1524632218.161929],
 [1524632218.1619892, 1524632219.187152],
 [1524632219.187215, 1524632220.207478],
 [1524632220.207537, 1524632221.231024],
 [1524632221.231082, 1524632222.255033],
 [1524632222.255092, 1524632223.084519],
 [1524632223.084579, 1524632223.900953]]
</pre></div>


<h4>Multithreading with 1 Thread</h4>
<p>In the visualizations below, each color represents the use of one thread in the operations. </p>
<p>So for multithreading with two threads, you'll see two color bars, one for each thread.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multithreading_effect</span><span class="p">(</span><span class="n">number_of_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 1 Thread&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_42_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x10f883240&gt;
</pre></div>


<h4>Multithreading with 2 Threads</h4>
<div class="highlight"><pre><span></span><span class="n">visualize_multithreading_effect</span><span class="p">(</span><span class="n">number_of_threads</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 2 Threads&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_44_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x10f96acf8&gt;
</pre></div>


<p>Let's visualize the effect of multithreading with 4 threads.</p>
<h4>Multithreading with 4 Threads</h4>
<div class="highlight"><pre><span></span><span class="n">visualize_multithreading_effect</span><span class="p">(</span><span class="n">number_of_threads</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 4 Threads&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_47_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x12d98ef98&gt;
</pre></div>


<h4>Multithreading with 8 Threads</h4>
<div class="highlight"><pre><span></span><span class="n">visualize_multithreading_effect</span><span class="p">(</span><span class="n">number_of_threads</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 8 Threads&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_49_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x12d963048&gt;
</pre></div>


<h4>Multiprocessing with 1 Process</h4>
<p>In the visualizations below, each color represents the use of one process in the operations. </p>
<p>So for multiprocessing with two concurrent processes, you'll see two color bars, one for each process.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 1 Process&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_52_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x10f320f98&gt;
</pre></div>


<h4>Multiprocessing with 2 Processes</h4>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 2 Processes&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_54_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x113d6f0f0&gt;
</pre></div>


<p>Let's visualize the effect of multiprocessing with 4 concurrent processes.</p>
<h4>Multiprocessing with 4 Processes</h4>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 4 Processes&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_57_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x10f2b6358&gt;
</pre></div>


<p>Let's visualize the effect of multiprocessing with 8 concurrent processes.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">get_response_time_measurements</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">twelve_urls</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for URL Server Responses; 8 Processes&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_59_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x12d976128&gt;
</pre></div>


<h4>Single Process and Thread</h4>
<p>Now, let's perform the same operation <strong>without</strong> the overhead of setting up multithreading.</p>
<div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">time</span>

<span class="c1"># traditional python program without multithreading</span>
<span class="n">task_timestamps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_response_time_measurements</span><span class="p">,</span> <span class="n">twelve_urls</span><span class="p">));</span>
</pre></div>


<div class="highlight"><pre><span></span>CPU times: user 410 ms, sys: 28.4 ms, total: 438 ms
Wall time: 16 s
</pre></div>


<p><strong>Conclusion:</strong> both multithreading and multiprocessing complete much quicker than a single thread &amp; program.</p>
<p>The reason parallel programming is much faster here is because the processor isn't working very hard to retreive the contents on the sites; however, the bottleneck is waiting for the site's server response to our HTTP request - an external resource. While one task is performing an operation of getting/waiting for a server response for one URL, another task can start for a different URL. </p>
<p>Threads are also fairly quick to combine their results too. So if we were web crawling and constantly wanted to combine results from multiple crawlers, it'd be ideal to use multiple threads to spawn multiple web crawlers rather than multiple processes which take longer to combine results.</p>
<h3>Example: Squares of Numbers</h3>
<p>Given this big list of numbers in <code>big_list</code>, we want to output a new list that has the square of all numbers in <code>big_list</code>.</p>
<p>Think of this as a <em>lot</em> of <em>small</em> operations.</p>
<div class="highlight"><pre><span></span><span class="n">big_list</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12000000</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square_value</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
</pre></div>


<h4>Multithreading</h4>
<p>Below I utilize code from another module of the Python standard library, <code>multiprocessing</code>, to perform multithreading for this operation. </p>
<p>By default, we will use all available threads on our computer.</p>
<div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">time</span>

<span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">()</span> 

<span class="n">squares_pool_results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">square_value</span><span class="p">,</span> <span class="n">big_list</span><span class="p">)</span>

<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>


<div class="highlight"><pre><span></span>CPU times: user 5.51 s, sys: 715 ms, total: 6.23 s
Wall time: 6.2 s
</pre></div>


<h4>Multiprocessing</h4>
<p>Below I utilize code from the lower-level module of the Python standard library, <code>multiprocessing</code>, to perform multiprocessing for this operation. </p>
<p>We'll use 2 concurrent processes.</p>
<div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">time</span>

<span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">multiprocessing_operation</span><span class="p">:</span>
    <span class="n">multiprocessing_operation</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">square_value</span><span class="p">,</span> <span class="n">big_list</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>CPU times: user 2.04 s, sys: 947 ms, total: 2.99 s
Wall time: 4.84 s
</pre></div>


<h4>Single Process &amp; Thread</h4>
<div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">time</span>

<span class="n">squares_results</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">square_value</span><span class="p">,</span> <span class="n">big_list</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>CPU times: user 13 µs, sys: 8 µs, total: 21 µs
Wall time: 26 µs
</pre></div>


<p><strong>Conclusion:</strong> process completes much faster <em>without</em> parallel programming.</p>
<p>This may come as a surprise that parallel programming hurts our performance here.</p>
<p>Using parallel programming in Python or any other interpreted language with a global interpreter lock (GIL) can actually result in reduced performance if you're <em>just</em> doing a CPU bound task. This program must carry parallel programming's additional overhead of creating new threads or processes and synchronizing their results. </p>
<h3>Example: CPU Heavy Computations</h3>
<p>In this example, we'll only perform 8 tasks - with each task requiring a large amount of math operations.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_all_intgers_from_zero_to_end_range_number</span><span class="p">(</span><span class="n">end_range_number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the sum of all integer numbers from 0 to end_range_number. </span>

<span class="sd">    :param end_range_number: highest value to loop over</span>
<span class="sd">    :type end_range_number: integer</span>

<span class="sd">    :returns [start_time, stop_time]: list of start_time of task and end time of task</span>
<span class="sd">    :return type: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="n">the_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_range_number</span><span class="p">):</span>
        <span class="n">the_sum</span> <span class="o">+=</span> <span class="n">number</span>
    <span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">start_time</span><span class="p">,</span> <span class="n">stop_time</span><span class="p">]</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">large_number</span> <span class="o">=</span> <span class="mi">11</span><span class="o">**</span><span class="mi">7</span>
<span class="n">iterations</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">large_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">large_number</span><span class="p">]</span><span class="o">*</span><span class="n">iterations</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">large_numbers</span>
</pre></div>


<div class="highlight"><pre><span></span>[19487171,
 19487171,
 19487171,
 19487171,
 19487171,
 19487171,
 19487171,
 19487171]
</pre></div>


<h4>Multithreading</h4>
<p>Let's visualize the effect of multithreading with 2 concurrent threads.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multithreading_effect</span><span class="p">(</span><span class="n">number_of_threads</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">sum_all_intgers_from_zero_to_end_range_number</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">large_numbers</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for Heavy CPU Computations; 2 Threads&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_85_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x10f2d0278&gt;
</pre></div>


<h4>Multiprocessing</h4>
<p>Let's visualize the effect of multiprocessing with 2 concurrent subprocesses.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">sum_all_intgers_from_zero_to_end_range_number</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">large_numbers</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for Heavy CPU Computations; 2 Processes&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_88_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x11b03c978&gt;
</pre></div>


<p>Let's visualize the effect of multiprocessing with 4 concurrent subprocesses.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">sum_all_intgers_from_zero_to_end_range_number</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">large_numbers</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for Heavy CPU Computations; 4 Processes&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_90_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x113e07978&gt;
</pre></div>


<p>Let's visualize the effect of multiprocessing with 5 concurrent subprocesses. </p>
<p>The runtime of this program is the same as that of 4 subprocess above. But why? Well, there's no benefit to attempting to use greater than 4 sub-processes for CPU bound tasks because my laptop has just 4 cores - the ability to run a single process concurrently on each core.</p>
<div class="highlight"><pre><span></span><span class="n">visualize_multiprocessing_effect</span><span class="p">(</span><span class="n">number_of_concurrent_processes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                <span class="n">function_name</span><span class="o">=</span><span class="n">sum_all_intgers_from_zero_to_end_range_number</span><span class="p">,</span>
                                <span class="n">iterable</span><span class="o">=</span><span class="n">large_numbers</span><span class="p">,</span>
                                <span class="n">plot_title</span><span class="o">=</span><span class="s2">&quot;Tasks for Heavy CPU Computations; 5 Processes&quot;</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="parallel_programming_files/parallel_programming_92_0.png"></p>
<div class="highlight"><pre><span></span>&lt;matplotlib.figure.Figure at 0x11b2bbb70&gt;
</pre></div>


<h4>Single Program &amp; Thread</h4>
<div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">time</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">sum_all_intgers_from_zero_to_end_range_number</span><span class="p">(</span><span class="n">large_number</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>CPU times: user 10.9 s, sys: 34.8 ms, total: 11 s
Wall time: 11 s
</pre></div>


<p><strong>Conclusion:</strong> program completes much faster <em>with</em> multiprocessing at approximately 4 subprocesses running concurrently.</p>
<p>Multiprocessing here was helpful for this CPU intensive task because we could benefit from using multiple cores and avoid the global interpreter lock.</p>
<p>Interestingly, spinning up additional subprocesses past 4 has no major effect on improving runtime of our program. Notice how the total program runtime with 4 subprocesses is equivalent to the program with 5 subprocesses.</p>
<p>Threads provide no benefit in Python for CPU intensive tasks like these because of the global interpreter lock.</p>
  </div>
</section>

  </div>
  
  <!-- start of footer section -->
  <footer class="footer">
    <div class="container">
      <p class="text-muted">
        <center>This project contains 68 pages and is available on <a href="https://github.com/frieds/frieds.github.io">GitHub</a>.
          <br/>
          Copyright &copy; Dan Friedman,
          <time datetime="2018">2018</time>.
        </center>
      </p>
    </div>
  </footer>

  <!-- JQuery -->
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E="
  crossorigin="anonymous"></script>

  <!-- This jQuery line finds any span that contains code highlighting classes and then selects the parent <pre> tag and adds a border and background. This is done as a workaround to visually distinguish the code inputs and outputs -->
  <script>
    $( ".hll, .n, .c, .err, .k, .o, .cm, .cp, .c1, .cs, .gd, .ge, .gr, .gh, .gi, .go, .gp, .gs, .gu, .gt, .kc, .kd, .kn, .kp, .kr, .kt, .m, .s, .na, .nb, .nc, .no, .nd, .ni, .ne, .nf, .nl, .nn, .nt, .nv, .ow, .w, .mf, .mh, .mi, .mo, .sb, .sc, .sd, .s2, .se, .sh, .si, .sx, .sr, .s1, .ss, .bp, .vc, .vg, .vi, .il" ).parent( "pre" ).css( "border", "1px solid #038f6d" );
    $( ".hll, .n, .c, .err, .k, .o, .cm, .cp, .c1, .cs, .gd, .ge, .gr, .gh, .gi, .go, .gp, .gs, .gu, .gt, .kc, .kd, .kn, .kp, .kr, .kt, .m, .s, .na, .nb, .nc, .no, .nd, .ni, .ne, .nf, .nl, .nn, .nt, .nv, .ow, .w, .mf, .mh, .mi, .mo, .sb, .sc, .sd, .s2, .se, .sh, .si, .sx, .sr, .s1, .ss, .bp, .vc, .vg, .vi, .il" ).parent( "pre" ).css( "background-color", "#d6eed9" );
  </script>

  <!-- Latest compiled and minified Bootstrap JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

  <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
  <script src="https://dfrieds.com/theme/js/ie10-viewport-bug-workaround.js"></script>
  <!-- <script type="text/javascript">
    $(document).on('click', 'a[href^="#"]', function (event) {
      event.preventDefault();
      $('html, body').animate({
        scrollTop: $($.attr(this, 'href')).offset().top
      }, 500);
    });
  </script> -->

</body>

</html>